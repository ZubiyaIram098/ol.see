Program :10
#include <stdio.h>

int main() {
    int block[10], process[10];
    int nb, np, alloc[10];
    int i, j;

    printf("Enter number of blocks: ");
    scanf("%d", &nb);

    printf("Enter block sizes:\n");
    for (i = 0; i < nb; i++)
        scanf("%d", &block[i]);

    printf("Enter number of processes: ");
    scanf("%d", &np);

    printf("Enter process sizes:\n");
    for (i = 0; i < np; i++)
        scanf("%d", &process[i]);

    for (i = 0; i < np; i++)
        alloc[i] = -1;

    // WORST FIT
    for (i = 0; i < np; i++) {
        int worst = -1;

        for (j = 0; j < nb; j++) {
            if (block[j] >= process[i]) {
                if (worst == -1 || block[j] > block[worst])
                    worst = j;
            }
        }

        if (worst != -1) {
            alloc[i] = worst;
            block[worst] -= process[i];
        }
    }

    // Output
    printf("\nProcess\tSize\tBlock\n");
    for (i = 0; i < np; i++) {
        printf("%d\t%d\t", i+1, process[i]);
        if (alloc[i] != -1)
            printf("%d\n", alloc[i] + 1);
        else
            printf("Not Allocated\n");
    }

    return 0;
}
Enter number of blocks: 4
Enter block sizes:
100 50 200 80

Enter number of processes: 4
Enter process sizes:
60 20 120 70
Process Size  Block
1       60     3
2       20     3
3      120     1
4       70     4
Best fit:
#include <stdio.h>

int main() {
    int block[10], process[10];
    int nb, np, alloc[10];
    int i, j;

    printf("Enter number of blocks: ");
    scanf("%d", &nb);

    printf("Enter block sizes:\n");
    for (i = 0; i < nb; i++)
        scanf("%d", &block[i]);

    printf("Enter number of processes: ");
    scanf("%d", &np);

    printf("Enter process sizes:\n");
    for (i = 0; i < np; i++)
        scanf("%d", &process[i]);

    for (i = 0; i < np; i++)
        alloc[i] = -1;

    // BEST FIT
    for (i = 0; i < np; i++) {
        int best = -1;

        for (j = 0; j < nb; j++) {
            if (block[j] >= process[i]) {
                if (best == -1 || block[j] < block[best])
                    best = j;
            }
        }

        if (best != -1) {
            alloc[i] = best;
            block[best] -= process[i];
        }
    }

    // Output
    printf("\nProcess\tSize\tBlock\n");
    for (i = 0; i < np; i++) {
        printf("%d\t%d\t", i+1, process[i]);
        if (alloc[i] != -1)
            printf("%d\n", alloc[i] + 1);
        else
            printf("Not Allocated\n");
    }

    return 0;
}
Output:
Enter number of blocks: 4
Enter block sizes:
100 40 70 30

Enter number of processes: 4
Enter process sizes:
35 20 40 60
Process Size  Block
1       35     3
2       20     2
3       40     1
4       60     Not Allocated
Program:9
/*Writer Process*/

#include <stdio.h>

#include <fcntl.h>

#include <sys/stat.h>

#include <sys/types.h>

#include <unistd.h>

int main()

int fd;

char buf[1024]:

/create the FIFO (named pipe) */

char myfifo="/tmp/myfifo";

mkfifo(myfifo, 0666);

printf("Run Reader process to read the FIFO File\n");

fdopen(myfifo, O_WRONLY);

write(fd, "Hi", sizeof("Hi"));

/* write "Hi" to the FIFO/

close(fd);

unlink(myfifo); /* remove the FIFO

return 0;
}
/* Reader Process*/

#include <fentl.h>

#include <sys/stat.h>

#include <sys/types.h>

#include <unistd.h>

#include <stdio.h>

#define MAX_BUF 1024

int main()

int fd:

A temp FIFO file is not created in reader */

char *myfifo-"/tmp/myfifo";

char buf[MAX_BUF]:

* open, read, and display the message from the FIFO

fd-open(myfifo, O_RDONLY);

read(fd, buf, MAX_BUF);

printf("Writer: %s\n", buf);

close(fd):

return 0;
}
Program :1
Demonstrate the use of process system calls for creation, execution, and termination of 
processes in Unix/Linux environments.
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h> // for fork(), exec(), getpid()
#include <sys/wait.h> // for wait()
int main() {
 pid_t pid;
 printf("Parent Process: PID = %d\n", getpid());
 // Create a child process
 pid = fork();
 if (pid < 0) {
 // Fork failed
 perror("Fork failed");
 exit(1);
 }
 else if (pid == 0) {
 // Child process block
 printf("Child Process: PID = %d, Parent PID = %d\n", getpid(), getppid());
 // Execute a new program (for example: "ls -l")
 printf("Child executing 'ls -l' command...\n");
 execl("/bin/ls", "ls", "-l", NULL);
 // If execl fails
 perror("execl failed");
 exit(1);
 }
 else {
 printf("Parent waiting for child process to finish...\n"); // Wait for child termination
 int status;
 wait(&status);
 if (WIFEXITED(status)) {
 printf("Child terminated normally with exit status %d\n", WEXITSTATUS(status));
 } else {
 printf("Child terminated abnormally.\n");
 }
 printf("Parent Process (PID = %d) terminating.\n", getpid());
 }
return 0;
}
Execution Steps
Compile : gcc process_demo.c -o process_demo
Run: ./process_demo
OUTPUT
Parent Process: PID = 3456
Parent waiting for child process to finish...
Child Process: PID = 3457, Parent PID = 3456
Child executing 'ls -l' command...
total 16
-rwxr-xr-x 1 user user 16728 Oct 3 12:30 process_demo
-rw-r--r-- 1 user user 832 Oct 3 12:29 process_demo.c
Child terminated normally with exit status 0
Parent Process (PID = 3456) terminating.
